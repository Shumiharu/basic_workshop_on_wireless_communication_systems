最初の基礎ゼミからやっといたほうが良いこと
(1)関数化なるべくする
しかし，最初はmain関数で作って正しい動作を確認してから関数化を試みた方がいいかも
(2)for(int i=0;   )の書き方は控える．→TeraTermのsv7とsv8以外エラーになる
(3)void()関数は配列の書き換えは可能だが，普通のdoubleとかintの値を書き換えることはできない．→mainに戻るときには値はリセットされる
(4)関数をmainの下に置くやり方
(5)ファイル出力するなら結果が出る場所はWinSCPのところ


＜基礎ゼミ01＞
kiso1_1.c　・・・複素数使わないversion
kiso1_2.c　・・・複素数使うversion　　　←こっちおすすめ！！！！！！

＜基礎ゼミ02＞
kiso2_1.c　・・・DFTを使ったプログラム
kiso2_2.c　・・・FFT（自作）を使ったプログラム(clock関数で処理時間計測)
fft_check1＆2　・・・自分が作ったFFTを奥村さんのFFT及びdftのふるまいの確認

※注意　(1)高速フーリエ変換にするとcabs()の値は変わらないが，順番が入れ替わる＝FFT結果がdft結果と異なる
　　　　(2)自作FFTはbit_lengthをいちいち変えなければいけない=log2(N)


＜基礎ゼミ03＞
kiso3_1.c　・・・基礎ゼミ03の内容すべて集約してる

※注意　(1)雑音電力2σ^2=1とする必要があり，σ^2の値は1/2になる．
　　　　(2)BnTsのやつ→指導書に貼った紙参照

※質問　(1)シンボル数を多くしたらBER特性はどうなる？→変わらない．ビット単位の誤りだから結局変化しない．BER=(ci+cq)/(2*loop*N);	としていてNで割ってるから



＜基礎ゼミ04＞
kiso4_1.c　・・・ルートロールオフ伝送系におけるQPSK信号のBER特性
kiso4_2.c　・・・ルートロールオフ伝送系における16QAM信号のBER特性

※注意　(1)OS比によらずBnTs=1とする．フィルタリングによって先頭サンプルのみに情報を集約するから，指導書に貼った紙参照
　　　　(2)ロールオフフィルタの式sqrt(N)する→指導書に貼った紙参照
　　　　(3)どこかidftにしないと受信信号がおかしくなる
　　　　(4)16QAMを作成するとき，A=1/sqrt(10*s)となっている理由→指導書の紙参照
        (5)QPSKから16QAMに変更するときBERの分母を4にする．
　　　　(6)FFTとIFFTとdftとidftの関数によって結果おかしくなる可能性あり
　―――――――――――――――――――――――――――――
　|　正しい結果が出るおすすめのやり方　			　　|
　|　時間波形→dftとidftのみで作る　　　　　　　　　　　　　|
　|　BER→時間がかかるので，FFTとIFFT（奥村さんの）を使う   |
　―――――――――――――――――――――――――――――

＜基礎ゼミ05＞
kiso5_1.c　・・・動的レイリーフェージングの時間波形，スペクトルのみ（図5-2から5-4）
kiso5_2.c　・・・動的レイリーフェージングの確率密度関数（図5-5と5-6）
kiso5_1.c　・・・準静的レイリーフェージング作成（図5-7）


※注意　(1)1フレーム長Kが大きすぎるのでmalloc関数（初見）で領域確保＋最後にfree関数で目盛り開放
　　　　(2)データ数が多いので，ファイル出力しなければいけない．
　　　　(3)電力スペクトル密度の平均電力を1に正規化してからルートをとる．→詳しくは基礎ゼミ05の一番下のページ参照
　　　　(4)電力スペクトル密度の計算式(f-fc)^2なのにプログラム上ではf[i]^2になってる
　　　　   →教科書で言うp.175の図A.2.4を作成している．理由：今はベースバンド帯域について考えているから．証拠に図5-4は±fd中心のスペクトルになってる
	　　 詳しい説明は指導書に貼った紙を参照
　　　　(5)σR^2の値と電力スペクトル密度の関係！
　　　　　 →電力スペクトル密度の総和に等しい　σR^2=1.0ならPsum=1.02W σR^2=2.0ならPsum=2.06 W
　　　　　 今回所望は平均電力を1WなのでPsum/Nと計算され，平均電力は1Wにならない．よって，正規化を行う必要がある．σR^2=Nとすれば平均電力1Wになるはず!
　　　　(6)フェージングの作成方法→指導書に貼った紙参照
　　　　(7)準静的レイリーフェージンは現実では存在しないのに作る意味→①世の中に時間変動しないフェージングはない②fd=0は端末が動いてないという意味だが，それはありえない．
　　　　　 ①の補足で，準静的レイリーフェージングも緩やかだが変動はしている．よって1フレーム内で一定とみなしてはいけない
　　　　　・動的レイリーフェージングでは1フレーム長Kを大きくしても確率密度関数がギザギザになる．しかし，準静的レイリーフェージングはガウス雑音をフレーム分コ
　　　　　　ピーするだけなので，分布がレイリー分布と位相分布になることは自明である．よって，Kが小さい準静的レイリーフェージングをつかい演算量を減らす．また準静的レイリ
　　　　　　ーフェージングにしてもBER特性に影響しない（基礎ゼミ06）ため用いる．
　　　　(8)準静的レイリーフェージングのプログラム→指導書に貼った紙参照
　　　　　 簡単に言うと，1フレームでKTs[sec]，K点分に同じawgnを付加するというやり方

＜基礎ゼミ06＞
kiso6_1.c　・・・動的または準静的レイリーフェージング環境下でのルートロールオフ伝送系におけるQPSKのBER特性（図6-1）
kiso6_2.c　・・・動的または準静的レイリーフェージング環境下でのルートロールオフ伝送系における16QAMのBER特性（図6-2）

※注意　(1)このあたりから先輩たちの関数化が著しい
　　　　(2)基礎ゼミ05と準静的レイリーフェージングの作り方微妙に違う．
　　　　　 基礎ゼミ05では1フレーム長Kすべてに同じガウス雑音をコピー
　　　　　 基礎ゼミ06ではベースバンド信号Kシンボル分の全サンプル数N(=s*K)に同じガウス雑音をコピー

-------------基礎ゼミ05------------------------------------------------------------基礎ゼミ06--------------------------------------------------------
for(i=0;i<K;i++){	//1フレーム単位でコピー	     |		for(i=0;i<N;i++){
	qsRfading[i+m*K]=noise[m];		     |			  qsRfading[i]=noise[0];//1フレームN=s*K点すべてに同じawgnを入れる．
};						     |		}
-------------------------------------------------------------------------------------------------------------------------------------------------------

＜基礎ゼミ07＞
kiso7_1.c　・・・QPSK-OFDM伝送時の時間波形，振幅スペクトル，BER特性（図7-4,7-6,7-8）
kiso7_2.c　・・・16QAM-OFDM伝送時の時間波形，振幅スペクトル，BER特性（図7-5,7-7,7-9）
kiso7_3.c　・・・QPSKor16QAM-OFDM信号の確率密度関数とPAPR，CCDFの算出（オプションPAPR特性）

※注意　(1)SP変換＝周波数領域の中央(-500Hz～500Hz)にベースバンド信号のTs毎のサンプル値を集約する関数
　　　　(2)PS変換＝中央に集まったデータを-500Hzの場所のサンプル値から順番に時間信号のTs毎に配置
　　　　(3)


＜基礎ゼミ08＞
kiso8_1.c　・・・準静的y[dB]減衰L波マルチパスフェージングモデルの作成
kiso8_2_kannsuukamae.c　・・・GI挿入とGI排除を関数化する前のQPSK-OFDMのBER特性算出
kiso8_2.c　・・・GI挿入とGI排除を関数化したQPSK-OFDMのBER特性算出
kiso8_3.c　・・・16QAM-OFDMのBER特性算出
kiso8_4.c　・・・SC-QPSKとSC-16QAMのBER特性

※注意　(1)マルチフェージングモデル作成の手順が自分と先輩で違う
　　　　(2)インパルス応答h0,h1,h2...は先頭サンプルのみに入れる→Excelのグラフ参照
　　　　   例えばs=4の時などはh0を4点分入れるわけではない→自分はこれで死んだ
　　　　(3)各パスの電力和が1Wとなるためのh[0]の値とY[dB]減衰時の電力比＝10^(-Y/10)→指導書の紙参照
　　　　　 インパルス応答を作るときの注意点①総電力を1Wにする　②減衰をY[dB]=10^(-Y/10)にする
　　　　(4)マルチパス通信路を通過するとき，「直接波」と「遅延波」をつくり，h0,h1,...と畳み込み和をとる
　　　　   L=4の時，直接波と遅延波3つを考える必要がある．遅延波は前回のループで作った，OFDM送信信号(雑音状の)をtmpにコピーして起き，遅延波を作るときにtmpを
　　　　　 遅延波1ならTs遅れなのでs点tmp，遅延波2なら2Ts送れなので2s点tmpを入れる




＜基礎ゼミ09＞
kiso9_1.c　･･･2次元，3次元配列にした時の関数の書き方のテスト，逆行列，行列の積のテスト
kiso9_2.c　･･･QPSK-OFDMのMIMO伝送のBER特性




※注意　(1)3次元配列の時は少なくとも2個の[]を関数内に入れないとだめ
--------------------------------------------良い例------------------------------------------------------------------------------------
	　 double complex ht[Nt][Nr][N],Hf[Nt][Nr][N];	
	   for(i=0;i<Nt;i++){
		for(j=0;j<Nr;j++)	
			FFT(ht[i][j],Hf[i][j]);　		//[N]を除いて，2つの[][]を指定したらOK
	   }	　　　　

------------------------------------------------------------------------------------------------------------------------------------------------


--------------------------------------------悪い例------------------------------------------------------------------------------------
	   void matrix_prod(double complex A[Nt][Nr][N],double complex B[Nr][1][N])
	   
	   
	   for(i=0;i<N;i++)
               matrix_prod(ht[i],y[i]);				//[N]の部分しか指定しておらず，エラーが起こる
------------------------------------------------------------------------------------------------------------------------------------------------
【結論】
・2次元配列の場合→少なくとも1つの[]は関数内に入れる
・3次元配列の場合→少なくとも2つの[]は関数内に入れる
・n次元配列の場合→少なくとも(n-1)つの[]は関数内に入れる

　　　　(2)








