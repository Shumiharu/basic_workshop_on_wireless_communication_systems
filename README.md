# 最初の基礎ゼミからやっといたほうが良いこと
> [!Warning]
> "プログラム_概要.txt"をREADMEに書き起こしたものになります．内容は正誤については確認しておらず，最新の基礎ゼミには対応していない可能性があります．その場合はみなさんで協力して更新してください．（清水）

1. **関数化なるべくする**
    - しかし，最初は`main`関数で作って正しい動作を確認してから関数化を試みた方がいいかも
2. **`for(int i=0; )`の書き方は控える**
    - TeraTermのsv7とsv8以外エラーになる
3. **`void()`関数は配列の書き換えは可能だが，普通の`double`とか`int`の値を書き換えることはできない**
    - `main`に戻るときには値はリセットされる
4. **関数を`main`の下に置くやり方**
5. **ファイル出力するなら結果が出る場所はWinSCPのところ**

## 基礎ゼミ01

- `kiso1_1.c`：複素数使わないversion
- `kiso1_2.c`：複素数使うversion（**おすすめ**）

## 基礎ゼミ02

- `kiso2_1.c`：DFTを使ったプログラム
- `kiso2_2.c`：FFT（自作）を使ったプログラム（`clock`関数で処理時間計測）
- `fft_check1`＆`2`：自分が作ったFFTを奥村さんのFFT及びdftのふるまいの確認

**注意**
1. 高速フーリエ変換にすると`cabs()`の値は変わらないが，順番が入れ替わる＝FFT結果がdft結果と異なる
2. 自作FFTは`bit_length`をいちいち変えなければいけない=`log2(N)`

## 基礎ゼミ03

- `kiso3_1.c`：基礎ゼミ03の内容すべて集約してる

**注意**
1. 雑音電力`2σ^2=1`とする必要があり，`σ^2`の値は`1/2`になる
2. `BnTs`のやつ→指導書に貼った紙参照

**質問**
1. シンボル数を多くしたらBER特性はどうなる？
    - 変わらない．ビット単位の誤りだから結局変化しない．`BER=(ci+cq)/(2*loop*N)`としていて`N`で割ってるから

## 基礎ゼミ04

- `kiso4_1.c`：ルートロールオフ伝送系におけるQPSK信号のBER特性
- `kiso4_2.c`：ルートロールオフ伝送系における16QAM信号のBER特性

**注意**
1. OS比によらず`BnTs=1`とする．フィルタリングによって先頭サンプルのみに情報を集約するから，指導書に貼った紙参照
2. ロールオフフィルタの式`sqrt(N)`する→指導書に貼った紙参照
3. どこか`idft`にしないと受信信号がおかしくなる
4. 16QAMを作成するとき，`A=1/sqrt(10*s)`となっている理由→指導書の紙参照
5. QPSKから16QAMに変更するときBERの分母を4にする
6. FFTとIFFTとdftとidftの関数によって結果おかしくなる可能性あり

**正しい結果が出るおすすめのやり方**
- 時間波形→dftとidftのみで作る
- BER→時間がかかるので，FFTとIFFT（奥村さんの）を使う

## 基礎ゼミ05

- `kiso5_1.c`：動的レイリーフェージングの時間波形，スペクトルのみ（図5-2から5-4）
- `kiso5_2.c`：動的レイリーフェージングの確率密度関数（図5-5と5-6）
- `kiso5_1.c`：準静的レイリーフェージング作成（図5-7）

**注意**
1. 1フレーム長Kが大きすぎるので`malloc`関数（初見）で領域確保＋最後に`free`関数でメモリ開放
2. データ数が多いので，ファイル出力しなければいけない
3. 電力スペクトル密度の平均電力を1に正規化してからルートをとる→詳しくは基礎ゼミ05の一番下のページ参照
4. 電力スペクトル密度の計算式`(f-fc)^2`なのにプログラム上では`f[i]^2`になってる
    - 教科書で言うp.175の図A.2.4を作成している．理由：今はベースバンド帯域について考えているから．証拠に図5-4は±fd中心のスペクトルになってる
    - 詳しい説明は指導書に貼った紙を参照
5. `σR^2`の値と電力スペクトル密度の関係！
    - 電力スペクトル密度の総和に等しい．`σR^2=1.0`なら`Psum=1.02W`，`σR^2=2.0`なら`Psum=2.06W`
    - 今回所望は平均電力を1Wなので`Psum/N`と計算され，平均電力は1Wにならない．よって，正規化を行う必要がある．`σR^2=N`とすれば平均電力1Wになるはず！
6. フェージングの作成方法→指導書に貼った紙参照
7. 準静的レイリーフェージングは現実では存在しないのに作る意味
    - 世の中に時間変動しないフェージングはない
    - `fd=0`は端末が動いてないという意味だが，それはありえない
    - 準静的レイリーフェージングも緩やかだが変動はしている．よって1フレーム内で一定とみなしてはいけない
    - 動的レイリーフェージングでは1フレーム長Kを大きくしても確率密度関数がギザギザになる．しかし，準静的レイリーフェージングはガウス雑音をフレーム分コピーするだけなので，分布がレイリー分布と位相分布になることは自明である．よって，Kが小さい準静的レイリーフェージングを使い演算量を減らす．また準静的レイリーフェージングにしてもBER特性に影響しない（基礎ゼミ06）ため用いる
8. 準静的レイリーフェージングのプログラム→指導書に貼った紙参照
    - 簡単に言うと，1フレームでKTs[sec]，K点分に同じawgnを付加するというやり方

## 基礎ゼミ06

- `kiso6_1.c`：動的または準静的レイリーフェージング環境下でのルートロールオフ伝送系におけるQPSKのBER特性（図6-1）
- `kiso6_2.c`：動的または準静的レイリーフェージング環境下でのルートロールオフ伝送系における16QAMのBER特性（図6-2）

**注意**
1. このあたりから先輩たちの関数化が著しい
2. 基礎ゼミ05と準静的レイリーフェージングの作り方微妙に違う．基礎ゼミ05では1フレーム長Kすべてに同じガウス雑音をコピーしているのに対して，基礎ゼミ06ではベースバンド信号Kシンボル分の全サンプル数N(=s*K)に同じガウス雑音をコピーしている．

#### 基礎ゼミ05
```c
for(i=0;i<K;i++){	
    qsRfading[i+m*K]=noise[m]; //1フレーム単位でコピー
};
```

#### 基礎ゼミ06
```c
for(i=0;i<N;i++){
    qsRfading[i]=noise[0] //1フレームN=s*K点すべてに同じawgnを入れる．
};
```

## 基礎ゼミ07

- `kiso7_1.c`：QPSK-OFDM伝送時の時間波形，振幅スペクトル，BER特性（図7-4, 7-6, 7-8）
- `kiso7_2.c`：16QAM-OFDM伝送時の時間波形，振幅スペクトル，BER特性（図7-5, 7-7, 7-9）
- `kiso7_3.c`：QPSKまたは16QAM-OFDM信号の確率密度関数とPAPR，CCDFの算出（オプションPAPR特性）

**注意**
1. SP変換＝周波数領域の中央（-500Hz～500Hz）にベースバンド信号のTs毎のサンプル値を集約する関数
2. PS変換＝中央に集まったデータを-500Hzの場所のサンプル値から順番に時間信号のTs毎に配置

## 基礎ゼミ08

- `kiso8_1.c`：準静的y[dB]減衰L波マルチパスフェージングモデルの作成
- `kiso8_2_kannsuukamae.c`：GI挿入とGI排除を関数化する前のQPSK-OFDMのBER特性算出
- `kiso8_2.c`：GI挿入とGI排除を関数化したQPSK-OFDMのBER特性算出
- `kiso8_3.c`：16QAM-OFDMのBER特性算出
- `kiso8_4.c`：SC-QPSKとSC-16QAMのBER特性

**注意**
1. マルチフェージングモデル作成の手順が自分と先輩で違う
2. インパルス応答h0, h1, h2...は先頭サンプルのみに入れる→Excelのグラフ参照

## 基礎ゼミ09

- `kiso9_1.c`：2次元，3次元配列にした時の関数の書き方のテスト，逆行列，行列の積のテスト
- `kiso9_2.c`：QPSK-OFDMのMIMO伝送のBER特性

**注意**
1. 3次元配列の時は少なくとも2個の`[]`を関数内に入れないとだめ

#### 良い例
```c
double complex ht[Nt][Nr][N],Hf[Nt][Nr][N];	
for(i=0;i<Nt;i++){
	for(j=0;j<Nr;j++)	
		FFT(ht[i][j],Hf[i][j]); //[N]を除いて，2つの[][]を指定したらOK
};
```

#### 悪い例
```c
void matrix_prod(double complex A[Nt][Nr][N],double complex B[Nr][1][N])
	   
	   
for(i=0;i<N;i++)
    matrix_prod(ht[i],y[i]); //[N]の部分しか指定しておらず，エラーが起こる
```
### 結論

- **2次元配列の場合**：少なくとも1つの`[]`は関数内に入れる
- **3次元配列の場合**：少なくとも2つの`[]`は関数内に入れる
- **n次元配列の場合**：少なくとも(n-1)つの`[]`は関数内に入れる


